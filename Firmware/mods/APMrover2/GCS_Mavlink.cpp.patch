diff --git a/APMrover2/GCS_Mavlink.cpp b/APMrover2/GCS_Mavlink.cpp
index e5e1654..fb52961 100644
--- a/APMrover2/GCS_Mavlink.cpp
+++ b/APMrover2/GCS_Mavlink.cpp
@@ -1131,6 +1131,36 @@ void GCS_MAVLINK::handleMessage(mavlink_message_t* msg)
             break;
         }
 
+    case MAVLINK_MSG_ID_MANUAL_CONTROL:
+    {
+        if(msg->sysid != rover.g.sysid_my_gcs) break;                         // Only accept control from our gcs
+        mavlink_manual_control_t    packet;
+        mavlink_msg_manual_control_decode(msg, &packet);
+        int16_t v[6];
+
+        // -UWA- Translate manual control messages to fixed raw RC values
+        // Input values are -1000 to 1000, output values are 1100 to 1900
+        // X: Pitch, Y: Roll, Z: Thrust, R: Yaw
+        const int16_t  MAX = 1000;
+        const int16_t  PWM_RANGE = 400;
+        const int16_t  PWM_MID = 1500;
+        v[0] = packet.y * PWM_RANGE / MAX + PWM_MID;    // Roll (aka turning)
+        v[1] = packet.x * PWM_RANGE / MAX + PWM_MID;    // Pitch
+        v[2] = packet.z * PWM_RANGE / MAX + PWM_MID;    // Throttle.
+        v[3] = packet.r * PWM_RANGE / MAX + PWM_MID;    // Yaw
+        v[4] = 1500;
+        v[5] = 1500;
+        v[6] = 1500;
+        v[7] = 1500;
+        // TODO: Modes/buttons.
+
+        hal.rcin->set_overrides(v, 8);
+
+        rover.failsafe.rc_override_timer = hal.scheduler->millis();
+        rover.failsafe_trigger(FAILSAFE_EVENT_RC, false);
+        break;
+    }
+
     case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE:
     {
         // allow override of RC channel values for HIL
